<html>
<head>
    <title>随机肉鸽许愿机</title>
    <style>
        body {
            padding-top: 10px;
            padding-left: 10px;
            padding-right: 10px;
            color: #FFF;
            text-shadow: -2px -2px #000, -2px -1px #000, -2px 0 #000, -2px 1px #000, -2px 2px #000, -1px -2px #000, -1px -1px #000, -1px 0 #000, -1px 1px #000, -1px 2px #000, 0 -2px #000, 0 -1px #000, 0 0 #000, 0 1px #000, 0 2px #000, 1px -2px #000, 1px -1px #000, 1px 0 #000, 1px 1px #000, 1px 2px #000, 2px -2px #000, 2px -1px #000, 2px 0 #000, 2px 1px #000, 2px 2px #000;
            text-align: center;
        }

        #div_overlay_container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 3044248;
            background-color: #000000EE;
        }

        .div_container {
            margin-top: 20px;
            margin-left: 20px;
            margin-right: 20px;
        }

        a:link, a:visited {
            color: #FFA500;
        }

        textarea {
            width: 100%;
            resize: none;
        }

        table {
            border-collapse: collapse;
        }

        .table_text {
            width: 100%;
            text-align: left;
            table-layout: fixed;
        }

        .table_text tr {
            height: 75px;
        }

        .table_text th {
            font-size: 2em;
            padding: 10px;
        }

        .table_text td {
            height: 75px;
            width: 50%;
            font-size: 1.5em;
        }

        #table_cost {
            color: #FFF;
        }

        #tr_warning {
            color: red;
        }

        td[id^="td_wish"], td[id^="td_cost"] {
            border-width: 1px;
            border-color: #AAAAAA;
            border-top-style: solid;
            border-bottom-style: solid;
            border-left-style: dashed;
            border-right-style: dashed;
            padding-left: 10px;
            padding-right: 10px;
        }

        #td_cost_result {
            border-width: 0px;
        }

        td[id^="td_cost"] span {
            color: #FFA500;
            margin-left: 5px;
            margin-right: 5px;
        }

        td[class="td_cost_not_paid"] {
            background-color: #fedcba;
        }

        #div_wish_options {
            position:absolute;
            margin-top: 15px;
        }

        .div_button {
            background-color: #F0F0F07F;
            padding: 10px;
            border-radius: 3px;
            border-color: #000;
            border-style: solid;
            border-width: 1px;
            text-align: center;
        }

        .wish_option {
            background-color: #DDDDDD7F;
            height: 32px;
            padding: 3px 10px;
            margin-top: 2px;
            border-radius: 3px;
            border-style: solid;
            border-width: 1px;
            border-color: #000;
        }

        .div_button:hover, .wish_option:hover {
            background-color: #2B666666;
        }

        #tr_notice {
            background-color: #ffbf92;
        }

        #td_notice {
            width: 80%;
            padding-left: 10px;
        }

        #td_notice_button {
            width: 20%;
            padding-right: 10px;
            text-align: right;
        }

        .div_notice_button {
            width: 50px;
            display: inline-block;
            background-color: #F0F0F07F;
            padding: 10px;
            border-radius: 3px;
            border-color: #000;
            border-style: solid;
            border-width: 1px;
            text-align: center;
        }

        .div_tag_button, .div_settings_button {
            width: 150px;
            display: inline-block;
            background-color: #F0F0F07F;
            padding: 10px;
            border-radius: 3px;
            border-color: #000;
            border-style: solid;
            border-width: 1px;
            text-align: center;
        }

        .div_tag_button:hover {
            outline-color: #00AAFF;
            outline-style: solid;
            outline-width: 3px;
        }

        .div_tag_button_enabled {
            background-color: #00AAFF;
        }

        .div_tag_button_enabled_useless {
            background-color: #bb5a5a;
        }

        .div_tag_button_disabled {
            background-color: #ebeb16;
        }

        .div_tag_button_disabled_useless {
            background-color: #76cb8b;
        }

        #td_md5 {
            text-align: center;
            opacity: 0;
        }

        #td_md5:hover {
            opacity: 1;
            background-color: #2B666666;
        }
    </style>
    <link rel="icon" href="./favicon.ico">
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-QGM58QCD7C"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());
        gtag('config', 'G-QGM58QCD7C');
    </script>
    <script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script>
</head>

<body>
    <div id="div_overlay_container" style="display:none">
        <div class="div_container">
            <table class="table_text" id="table_cost">
                <tr>
                    <td colspan="2">
                        <div class="div_button" id="div_cost_exit" onclick="handle_overlay();">关闭</div>
                    </td>
                </tr>
                <tr></tr>
                <tr>
                    <td colspan="2" id="td_tag_comment">
                        代价需求（最多3项）
                    </td>
                </tr>
                <tr>
                    <td colspan="2">
                        <div class="div_tag_button" id='div_tag_0' onclick="handle_tag(0);">代价需求1</div>
                        <div class="div_tag_button" id='div_tag_1' onclick="handle_tag(1);">代价需求2</div>
                        <div class="div_tag_button" id='div_tag_2' onclick="handle_tag(2);">代价需求3</div>
                    </td>
                </tr>
                <tr>
                    <td colspan="2">
                        <div class="div_tag_button" id='div_tag_3' onclick="handle_tag(3);">代价需求4</div>
                        <div class="div_tag_button" id='div_tag_4' onclick="handle_tag(4);">代价需求5</div>
                        <div class="div_tag_button" id='div_tag_5' onclick="handle_tag(5);" style="display: none;">代价需求6</div>
                    </td>
                </tr>
                <tr id="tr_tag_row_3" style="display: none;">
                    <td colspan="2">
                        <div class="div_tag_button" id='div_tag_6' onclick="handle_tag(6);">代价需求7</div>
                        <div class="div_tag_button" id='div_tag_7' onclick="handle_tag(7);">代价需求8</div>
                        <div class="div_tag_button" id='div_tag_8' onclick="handle_tag(8);">代价需求9</div>
                    </td>
                </tr>
                <tr>
                    <td colspan="2" id="td_cost_result">
                        这里显示抽出的代价
                    </td>
                </tr>
                <tr>
                    <td colspan="2">
                        <div class="div_button" id="div_cost_OK">确认</div>
                    </td>
                </tr>
            </table>
        </div>
    </div>
    <table class="table_text">
        <tr>
            <td>
                <div class="div_button" id="div_settings" onclick="handle_button_settings();">设置</div>
            </td>
            <td>
                <div class="div_button" onclick="location.reload();">清空（刷新）</div>
            </td>
        </tr>
    </table>
    <table class="table_text" id="table_settings" style="display:none">
        <tr id="tr_warning" style="display:none"></tr>
        <tr style="display:none">
            <td colspan="2">
                当前设置md5：<span id="span_md5_1">undefined</span>
            </td>
        </tr>
        <tr style="display:none">
            <td colspan="2">
                <div class="div_settings_button" onclick="handle_notice(101);">使用默认设置</div>
                <div class="div_settings_button" onclick="handle_notice(102);">恢复之前设置</div>
            </td>
        </tr>
        <tr>
            <td>
                <a href="./old.html">打开标准版本</a>
            </td>
        </tr>
        <tr>
            <td colspan="2">
                测试版本暂时不能修改设置喵，但是可以 <a href="./beta.json">查看愿望和代价</a>
            </td>
        </tr>
        <tr style="display:none">
            <td colspan="2">
                愿望：
                <textarea id="textarea_wish" rows="10"></textarea>
            </td>
        </tr>
        <tr style="display:none">
            <td colspan="2">
                代价：
                <textarea id="textarea_cost" rows="10"></textarea>
            </td>
        </tr>
    </table>
    <table class="table_text">
        <tr id="tr_notice" style="display:none">
            <td id="td_notice"></td>
            <td id="td_notice_button"></td>
        </tr>
    </table>
    <table class="table_text" id="table_main">
        <tr style="display:none">
            <td colspan="2" id="td_md5" onclick="handle_td_md5();">
                当前设置md5：<span id="span_md5_0">undefined</span>
            </td>
        </tr>
        <tr>
            <td colspan="2" id="td_notice_2">
                <span style="color:#ebeb16">暂时了移除不兼容萨米肉鸽的代价</span>
            </td>
        </tr>
        <tr>
            <th>我可以</th>
            <th>但代价是</th>
        </tr>
    </table>

    <script>
        const choose_one = "选择一个愿望";
        const question_mark = '？';
        const window_length = 10;
        let current_row = 0;
        let current_settings = {
            "wish" : [],
            "cost": [],
        };
        let current_wish_index = -1;
        let last_toggle = 0;
        let current_settings_md5 = '';
        let default_settings_md5 = '';
        let last_checked = ''; // the last checked default_settings_md5
        let default_settings, update_message;
        let cost_mode = 0;
        let current_cost_pool = [];
        let current_tag_pool = [];
        let current_enabled_tag_indices = new Set();
        let current_disabled_tag_indices = new Set();
        let flag_handle_cost_done = false;

        function handle_cost() {
            // 禁用关闭按钮和确认按钮
            document.getElementById('div_cost_OK').innerHTML = '请稍候';
            document.getElementById('div_cost_OK').onclick = undefined;
            document.getElementById('div_cost_exit').innerHTML = '请稍候';
            document.getElementById('div_cost_exit').onclick = undefined;

            let cost_result;
            if (cost_mode == 0) {
                // 公开招募模式，选择想要的标签筛选代价
                // 首先搜索完全包含所选标签的代价
                let current_enabled_tags = [];
                let cost_with_enabled_tags = [];
                console.log('当前标签池', current_tag_pool);
                for (let i = 0; i < current_tag_pool.length; i++) {
                    if (current_enabled_tag_indices.has(i)) {
                        current_enabled_tags.push(current_tag_pool[i]);
                    }
                }
                console.log('当前选中标签', current_enabled_tags);
                for (let i = 0; i < current_cost_pool.length; i++) {
                    // 标签集合为所选标签集合的超集的代价就会被选中
                    if (isSuperset(new Set(current_cost_pool[i]['tag']), new Set(current_enabled_tags))) {
                        cost_with_enabled_tags.push(current_cost_pool[i]);
                    }
                }
                if (cost_with_enabled_tags.length > 0) {
                    console.log(`共有${cost_with_enabled_tags.length}条代价完全符合条件，从中随机选择一条`);
                    console.log(cost_with_enabled_tags);
                    cost_result = sample(cost_with_enabled_tags, 1)[0];
                }
                else {
                    // 代价池中没有任何一条代价完全满足所选标签的情况
                    // （80%的概率）首先仅划掉部分所选标签
                    // 标签集合与所选标签集合的交集不为空的代价就会被选中
                    console.log(`代价池中没有任何一条代价完全满足所选标签`);
                    for (let i = 0; i < current_cost_pool.length; i++) {
                        if (intersection(new Set(current_cost_pool[i]['tag']), new Set(current_enabled_tags)).size > 0) {
                            cost_with_enabled_tags.push(current_cost_pool[i]);
                        }
                    }
                    console.log(`共有${cost_with_enabled_tags.length}条代价符合条件（划掉部分），从中随机选择一条`);
                    console.log(cost_with_enabled_tags);
                    cost_result = sample(cost_with_enabled_tags, 1)[0];
                    if (Math.random() < 0.2) {
                        // 20%的概率划掉所有标签
                        // 直接从代价中随机选择一条
                        // 可能出现标签被划掉了但是随机选择后实际有效，之后也显示为有效的情况，不过没有关系
                        console.log(`全 划 了，从全部代价中随机选择一条`);
                        cost_result = sample(current_cost_pool, 1)[0];
                    }
                }
                console.log('代价：', cost_result['text']);
                console.log('标签：', cost_result['tag']);

                let result_tag_set = new Set(cost_result['tag']);
                // 实际有效的标签
                let tag_useful_set = intersection(new Set(current_enabled_tags), result_tag_set);
                console.log('tag_useful_set', tag_useful_set);

                // 没用上的标签，划掉
                let tag_useless_set = difference(new Set(current_enabled_tags), result_tag_set);
                console.log('tag_useless_set', tag_useless_set);

                // 把标签涂上对应的颜色
                // 选中的标签有效时保持蓝色
                // 选中的标签无效时涂上红色
                // 未被选中的标签有效时保持未被选中
                // 未被选中的标签无效时保持未被选中
                for (let i = 0; i < 5; i++) {
                    if (tag_useless_set.has(document.getElementById(`div_tag_${i}`).innerHTML)) {
                        document.getElementById(`div_tag_${i}`).classList.remove('div_tag_button_enabled');
                        document.getElementById(`div_tag_${i}`).classList.add('div_tag_button_enabled_useless');
                    }
                }
            }
            else if (cost_mode == 1) {
                // 反向公开招募模式，选择（禁用、划掉）不想要的标签排除代价
                // 此处“划掉”所选标签表示“使标签重新有效化” Make Tag Enabled Again
                // 首先搜索完全不包含所选标签的代价
                let current_disabled_tags = [];
                let cost_without_disabled_tags = [];
                console.log('当前标签池', current_tag_pool);
                for (let i = 0; i < current_tag_pool.length; i++) {
                    if (current_disabled_tag_indices.has(i)) {
                        current_disabled_tags.push(current_tag_pool[i]);
                    }
                }
                console.log('当前禁用标签', current_disabled_tags);
                for (let i = 0; i < current_cost_pool.length; i++) {
                    // 标签集合与所选标签集合的交集为空的代价就会被选中
                    if (intersection(new Set(current_cost_pool[i]['tag']), new Set(current_disabled_tags)).size == 0) {
                        cost_without_disabled_tags.push(current_cost_pool[i]);
                    }
                }
                console.log(`共有${cost_without_disabled_tags.length}条代价完全符合条件`);
                let roll_success = Math.floor(Math.random() * 100)
                console.log(`0到99的随机数等于${roll_success}`)
                console.log(`符合条件的代价大于0条且随机数小于50时禁用成功`)
                // 50%的概率禁用完全有效
                if (cost_without_disabled_tags.length > 0 && roll_success < 50) {
                    console.log(`禁用成功了`);
                    console.log(`从符合条件的代价中随机选择一条`);
                    console.log(cost_without_disabled_tags);
                    cost_result = sample(cost_without_disabled_tags, 1)[0];
                }
                // 50%的概率禁用失败
                else {
                    // 代价池中没有任何一条代价完全不包含所选标签的情况
                    // （80%的概率）首先仅划掉部分所选标签
                    // 标签集合与所选标签集合的交集不为空且为所选标签集合的真子集的代价就也会被选中
                    console.log(`禁用失败了`);
                    for (let i = 0; i < current_cost_pool.length; i++) {
                        let set_1 = intersection(new Set(current_cost_pool[i]['tag']), new Set(current_disabled_tags));
                        if (set_1.size > 0 && set_1.size < new Set(current_disabled_tags).size) {
                            cost_without_disabled_tags.push(current_cost_pool[i]);
                        }
                    }
                    console.log(`共有${cost_without_disabled_tags.length}条代价符合条件（禁用失败），从中随机选择一条`);
                    console.log(cost_without_disabled_tags);
                    cost_result = sample(cost_without_disabled_tags, 1)[0];
                    if (Math.random() < 0.2 || !cost_result) {
                        // 20%的概率划掉所有标签（全部有效化）
                        // 仅划掉部分所选标签时也没有任何一条代价完全不包含剩余所选标签的情况也需要直接随机选择
                        // 直接从代价中随机选择一条
                        // 可能出现标签被划掉了但是随机选择后实际有效，之后也显示为有效的情况，不过没有关系
                        console.log(`全 划 了，从全部代价中随机选择一条`);
                        cost_result = sample(current_cost_pool, 1)[0];
                    }
                }
                console.log('代价：', cost_result['text']);
                console.log('标签：', cost_result['tag']);

                let result_tag_set = new Set(cost_result['tag']);
                // 实际有效的标签（此处“有效”表示所选标签不在代价的标签集合中，起到了禁用效果）
                let tag_useful_set = difference(new Set(current_disabled_tags), result_tag_set);
                console.log('实际有效的标签', tag_useful_set);

                // 没用上的标签，划掉（此处“没用上”表示所选标签在代价的标签集合中，没起到禁用效果）
                let tag_useless_set = intersection(new Set(current_disabled_tags), result_tag_set);
                console.log('没用上的标签', tag_useless_set);

                // 把标签涂上对应的颜色
                // 禁用的标签禁用有效时保持黄色
                // 禁用的标签禁用无效时涂上绿色
                // 未被选中的标签有效时涂上蓝色
                // 未被选中的标签无效时保持未被选中
                for (let i = 0; i < 9; i++) {
                    let tag_text = document.getElementById(`div_tag_${i}`).innerHTML;
                    if (result_tag_set.has(tag_text)) {
                        if (tag_useless_set.has(tag_text)) {
                            document.getElementById(`div_tag_${i}`).classList.remove('div_tag_button_disabled');
                            document.getElementById(`div_tag_${i}`).classList.add('div_tag_button_disabled_useless');
                        }
                        else {
                            document.getElementById(`div_tag_${i}`).classList.add('div_tag_button_enabled');
                        }
                    }
                }
            }
            else if (cost_mode == 2) {
                // 正反向同时公开招募模式，选择想要的标签筛选代价，选择（禁用、划掉）不想要的标签排除代价
                // 此处“划掉”所选标签表示“使标签重新有效化” Make Tag Enabled Again
                // 首先搜索完全不包含所选标签的代价
                let current_enabled_tags = [];
                let current_disabled_tags = [];
                let cost_with_enabled_tags = [];
                let cost_without_disabled_tags = [];
                console.log('当前标签池', current_tag_pool);
                for (let i = 0; i < current_tag_pool.length; i++) {
                    if (current_enabled_tag_indices.has(i)) {
                        current_enabled_tags.push(current_tag_pool[i]);
                    }
                    if (current_disabled_tag_indices.has(i)) {
                        current_disabled_tags.push(current_tag_pool[i]);
                    }
                }
                console.log('当前禁用标签', current_disabled_tags);
                // 首先走反向公招的流程，禁用
                for (let i = 0; i < current_cost_pool.length; i++) {
                    // 标签集合与所选标签集合的交集为空的代价就会被选中
                    if (intersection(new Set(current_cost_pool[i]['tag']), new Set(current_disabled_tags)).size == 0) {
                        cost_without_disabled_tags.push(current_cost_pool[i]);
                    }
                }
                console.log(`共有${cost_without_disabled_tags.length}条代价符合条件`);
                let roll_success = Math.floor(Math.random() * 100)
                console.log(`0到99的随机数等于${roll_success}`)
                console.log(`符合条件的代价大于0条且随机数小于50时禁用成功`)
                // 50%的概率禁用完全有效
                if (cost_without_disabled_tags.length > 0 && roll_success < 50) {
                    console.log(`禁用成功了`);
                    console.log(`之后从符合条件的代价中正向筛选`);
                    console.log(cost_without_disabled_tags);
                }
                // 50%的概率禁用失败
                else {
                    // 代价池中没有任何一条代价完全不包含所选标签的情况
                    // （80%的概率）首先仅划掉部分所选标签
                    // 标签集合与所选标签集合的交集不为空且为所选标签集合的真子集的代价就也会被选中
                    console.log(`禁用失败了`);
                    for (let i = 0; i < current_cost_pool.length; i++) {
                        let set_1 = intersection(new Set(current_cost_pool[i]['tag']), new Set(current_disabled_tags));
                        if (set_1.size > 0 && set_1.size < new Set(current_disabled_tags).size) {
                            cost_without_disabled_tags.push(current_cost_pool[i]);
                        }
                    }
                    console.log(`共有${cost_without_disabled_tags.length}条代价符合条件（禁用失败），之后从中正向筛选`);
                    console.log(cost_without_disabled_tags);
                    cost_result = sample(cost_without_disabled_tags, 1)[0];
                    if (Math.random() < 0.2 || !cost_result) {
                        // 20%的概率划掉所有标签（全部有效化）
                        // 仅划掉部分所选标签时也没有任何一条代价完全不包含剩余所选标签的情况也需要直接随机选择
                        // 直接从代价中随机选择一条
                        // 可能出现标签被划掉了但是随机选择后实际有效，之后也显示为有效的情况，不过没有关系
                        console.log(`全 划 了，从全部代价中正向筛选`);
                        cost_without_disabled_tags = current_cost_pool;
                    }
                }

                // 然后正向筛选，搜索完全包含所选标签的代价
                console.log('当前标签池（已经过反向公招禁用）', cost_without_disabled_tags);
                console.log('当前选中标签', current_enabled_tags);
                for (let i = 0; i < cost_without_disabled_tags.length; i++) {
                    // 标签集合为所选标签集合的超集的代价就会被选中
                    if (isSuperset(new Set(cost_without_disabled_tags[i]['tag']), new Set(current_enabled_tags))) {
                        cost_with_enabled_tags.push(cost_without_disabled_tags[i]);
                    }
                }
                if (cost_with_enabled_tags.length > 0) {
                    console.log(`共有${cost_with_enabled_tags.length}条代价完全符合条件，从中随机选择一条`);
                    console.log(cost_with_enabled_tags);
                    cost_result = sample(cost_with_enabled_tags, 1)[0];
                }
                else {
                    // 代价池中没有任何一条代价完全满足所选标签的情况
                    // （80%的概率）首先仅划掉部分所选标签
                    // 标签集合与所选标签集合的交集不为空的代价就会被选中
                    console.log(`代价池中没有任何一条代价完全满足所选标签`);
                    for (let i = 0; i < cost_without_disabled_tags.length; i++) {
                        if (intersection(new Set(cost_without_disabled_tags[i]['tag']), new Set(current_enabled_tags)).size > 0) {
                            cost_with_enabled_tags.push(cost_without_disabled_tags[i]);
                        }
                    }
                    console.log(`共有${cost_with_enabled_tags.length}条代价符合条件（划掉部分），从中随机选择一条`);
                    console.log(cost_with_enabled_tags);
                    cost_result = sample(cost_with_enabled_tags, 1)[0];
                    if (Math.random() < 0.2) {
                        // 20%的概率划掉所有标签
                        // 直接从代价中随机选择一条
                        // 可能出现标签被划掉了但是随机选择后实际有效，之后也显示为有效的情况，不过没有关系
                        console.log(`全 划 了，从全部代价中随机选择一条`);
                        // TODO：随机选择的范围？
                        cost_result = sample(cost_without_disabled_tags, 1)[0];
                    }
                }
                console.log('代价：', cost_result['text']);
                console.log('标签：', cost_result['tag']);

                // 被选中代价的标签集合
                let result_tag_set = new Set(cost_result['tag']);

                // 选中了且实际有效的标签
                let tag_enabled_useful_set = intersection(new Set(current_enabled_tags), result_tag_set);
                console.log('选中了且实际有效的标签', tag_enabled_useful_set);

                // 选中了且没用上的标签，划掉
                let tag_enabled_useless_set = difference(new Set(current_enabled_tags), result_tag_set);
                console.log('选中了且没用上的标签', tag_enabled_useless_set);

                // 禁用了且实际有效的标签（此处“有效”表示所选标签不在代价的标签集合中，起到了禁用效果）
                let tag_disabled_useful_set = difference(new Set(current_disabled_tags), result_tag_set);
                console.log('禁用了且实际有效的标签', tag_disabled_useful_set);

                // 禁用了且没用上的标签，划掉（此处“没用上”表示所选标签在代价的标签集合中，没起到禁用效果）
                let tag_disabled_useless_set = intersection(new Set(current_disabled_tags), result_tag_set);
                console.log('禁用了且没用上的标签', tag_disabled_useless_set);

                // 把标签涂上对应的颜色
                // 选中的标签有效时保持蓝色
                // 选中的标签无效时涂上红色
                // 禁用的标签禁用有效时保持黄色
                // 禁用的标签禁用无效时涂上绿色
                // 未被选中的标签有效时保持未被选中
                // 未被选中的标签无效时保持未被选中
                for (let i = 0; i < 9; i++) {
                    let tag_text = document.getElementById(`div_tag_${i}`).innerHTML;
                    if (result_tag_set.has(tag_text)) {
                        // 标签在代价的标签集合中
                        if (tag_disabled_useless_set.has(tag_text)) {
                            document.getElementById(`div_tag_${i}`).classList.remove('div_tag_button_disabled');
                            document.getElementById(`div_tag_${i}`).classList.add('div_tag_button_disabled_useless');
                        }
                    }
                    if (!result_tag_set.has(tag_text)) {
                        // 标签不在代价的标签集合中
                        if (tag_enabled_useless_set.has(tag_text)) {
                            document.getElementById(`div_tag_${i}`).classList.remove('div_tag_button_enabled');
                            document.getElementById(`div_tag_${i}`).classList.add('div_tag_button_enabled_useless');
                        }
                    }
                }
            }

            let cost_length;
            let block_text, cost_text;
            if (current_wish_index == -1) {
                current_wish_index = Math.floor(Math.random() * Math.max(1, current_settings['wish'].length - 1)) + 1;
            }
            document.getElementById(`td_wish_${current_row}`).innerHTML = current_settings['wish'][current_wish_index];
            block_text = question_mark.repeat(window_length);
            for (let i = 0; i < 10; i++) {
                setTimeout(() => {
                    let j = Math.floor(Math.random() * current_settings['cost'].length);
                    let text = current_settings['cost'][j]['text'] + block_text;
                    text = text.slice(0, window_length);
                    draw_cost(text);
                }, i * 100);
            }
            cost_text = cost_result['text'];
            // 10% extra cost
            // if (Math.random() < 0.1) {
            //     cost_text += '；{且立即额外抽取1个代价}';
            // }
            cost_text = cost_text.replace(/{/g, '<span>').replace(/}/g, '</span>');
            cost_length = cost_text.length;
            setTimeout(() => draw_cost(block_text), 1000);
            if (cost_length < window_length) {
                for (let k = 1; k <= window_length; k++) {
                    setTimeout(() => {
                        let text = '';
                        if (k + cost_length - window_length > 0) {
                            text = cost_text.slice(window_length - k, cost_length);
                        }
                        text = block_text.slice(0, window_length - k) + text;
                        text = text.slice(0, Math.max(cost_length, window_length - k));
                        draw_cost(text);
                    }, 1233 + k * 1000 / window_length);
                }
            }
            else {
                for (let k = 1; k <= cost_length; k++) {
                    setTimeout(() => {
                        let text = cost_text.slice(0, k);
                        if (k < window_length) {
                            text = text + block_text;
                            text = text.slice(0, window_length);
                        }
                        draw_cost(text);
                    }, 1233 + k * 1000 / cost_length);
                }
            }

            setTimeout(() => {
                flag_handle_cost_done = true;
                document.getElementById('div_cost_OK').innerHTML = '关闭';
                document.getElementById('div_cost_OK').onclick = handle_overlay;
                document.getElementById('div_cost_exit').innerHTML = '关闭';
                document.getElementById('div_cost_exit').onclick = handle_overlay;
                document.getElementById(`td_cost_${current_row}`).innerHTML = cost_text;
                draw_row();
                // 随机决定下一次抽取代价的模式
                // cost_mode = Math.floor(Math.random() * 2);
                // 锁定测试新模式
                cost_mode = 2;
            }, 2333);
        }

        function draw_row(new_row=true) {
            let options, row_content;
            if (new_row) {
                current_row += 1;
            }
            options = `<div id="div_wish_options" style="display:none">`;
            for (let i = 0; i < current_settings['wish'].length; i++) {
                options += `
                    <div class="wish_option" id="div_wish_option_${i}" onclick="handle_wish(${i});">
                        ${current_settings['wish'][i]}
                    </div>
                `;
            }
            options += `</div>`;
            wish_row_content = `
                <td id="td_wish_${current_row}">
                    <div class="div_button" id="div_wish" onclick="handle_wish(-1);">
                        点击选择一个愿望 或者 直接抽取→
                    </div>
                    ${options}
                </td>
                <td id="td_cost_${current_row}" onclick="handle_cost_paid(this.id);">
                    <div class="div_button" onclick="handle_overlay();">开始抽取代价</div>
                </td>
            `;
            if (new_row) {
                document.getElementById("table_main").innerHTML += `
                    <tr id="tr_${current_row}">
                        ${wish_row_content}
                    </tr>
                `;
                current_wish_index = -1;
            }
            else {
                document.getElementById(`tr_${current_row}`).innerHTML = wish_row_content;
            }
        }

        function handle_tag(tag_id) {
            let div_tag = `div_tag_${tag_id}`;
            let max_enabled_tags_cnt = 3;
            let max_disabled_tags_cnt = 5;
            if (cost_mode == 0) {
                // 公开招募模式
                if (current_enabled_tag_indices.has(tag_id)) {
                    document.getElementById(div_tag).classList.remove('div_tag_button_enabled');
                    current_enabled_tag_indices.delete(tag_id);
                }
                else {
                    if (current_enabled_tag_indices.size < max_enabled_tags_cnt) {
                        // 不能超过可选标签上限
                        document.getElementById(div_tag).classList.add('div_tag_button_enabled');
                        current_enabled_tag_indices.add(tag_id);
                    }
                }
            }
            if (cost_mode == 1) {
                // 反向公开招募模式
                if (current_disabled_tag_indices.has(tag_id)) {
                    document.getElementById(div_tag).classList.remove('div_tag_button_disabled');
                    current_disabled_tag_indices.delete(tag_id);
                }
                else {
                    if (current_disabled_tag_indices.size < max_disabled_tags_cnt) {
                        // 不能超过可选标签上限
                        document.getElementById(div_tag).classList.add('div_tag_button_disabled');
                        current_disabled_tag_indices.add(tag_id);
                    }
                }
            }
            if (cost_mode == 2) {
                // 正反向同时公开招募模式
                if (current_enabled_tag_indices.has(tag_id)) {
                    // 标签被选中状态
                    // 总之解除被选中状态
                    document.getElementById(div_tag).classList.remove('div_tag_button_enabled');
                    current_enabled_tag_indices.delete(tag_id);
                    // 切换状态
                    if (current_disabled_tag_indices.size < max_disabled_tags_cnt) {
                        // 禁用标签数未达到上限时，禁用标签
                        // 否则恢复至未被选中状态，else略
                        document.getElementById(div_tag).classList.add('div_tag_button_disabled');
                        current_disabled_tag_indices.add(tag_id);
                    }
                }
                else if (current_disabled_tag_indices.has(tag_id)) {
                    // 标签被禁用状态
                    // 总之解除被禁用状态
                    // 解除后总是可以恢复至未被选中状态，无需条件
                    document.getElementById(div_tag).classList.remove('div_tag_button_disabled');
                    current_disabled_tag_indices.delete(tag_id);
                }
                else {
                    // 标签既未被选中又未被禁用，为未被选中状态（初始状态）
                    // 切换状态
                    if (current_enabled_tag_indices.size < max_enabled_tags_cnt) {
                        // 选中标签数未达到上限时，选中标签
                        document.getElementById(div_tag).classList.add('div_tag_button_enabled');
                        current_enabled_tag_indices.add(tag_id);
                    }
                    else {
                        // 否则尝试直接切换至禁用状态
                        if (current_disabled_tag_indices.size < max_disabled_tags_cnt) {
                            // 禁用标签数未达到上限时，禁用标签
                            // 否则恢复至未被选中状态，else略
                            document.getElementById(div_tag).classList.add('div_tag_button_disabled');
                            current_disabled_tag_indices.add(tag_id);
                        }
                    }
                    // 选中标签和禁用标签都已满时，什么都不做，保持未被选中状态，点击无效
                }
            }
        }

        function get_tag_set(cost_list) {
            let tag_set = new Set();
            for (let i = 0; i < cost_list.length; i++) {
                for (let j = 0; j < cost_list[i]['tag'].length; j++){
                    tag_set.add(cost_list[i]['tag'][j]);
                }
            }
            return tag_set;
        }

        function reset_cost_tag_pool() {
            // 初始化代价池和标签池
            // 公开招募模式：随机选出10条代价，标签总数小于5时，重新随机选择代价，直到标签总数大于等于5
            // 反向公开招募模式：随机选出16条代价，标签总数小于9时，重新随机选择代价，直到标签总数大于等于9
            // 正反向同时公开招募模式：随机选出16条代价，标签总数小于9时，重新随机选择代价，直到标签总数大于等于9
            let retry_cnt = 0;
            let tag_set = new Set();
            let tag_cap = cost_mode == 0 ? 10 : 16;
            let tag_cnt = cost_mode == 0 ? 5 : 9;
            while (tag_set.size < tag_cnt && retry_cnt < 10) {
                retry_cnt += 1;
                current_cost_pool = sample(current_settings['cost'], tag_cap);
                tag_set = get_tag_set(current_cost_pool);
                console.log('当前代价池', current_cost_pool);
                console.log('当前代价池中所有代价的标签集合', tag_set);
            }
            // 首先随机选1条代价，随机选择2至3个标签，但最多不超过它的标签总数
            let cost_1 = current_cost_pool[Math.floor(Math.random() * current_cost_pool.length)];
            let tag_1_cnt = Math.min(cost_1['tag'].length, Math.floor(Math.random() * 2) + 2);
            let tag_1 = sample(cost_1['tag'], tag_1_cnt);
            console.log(cost_1['text'], cost_1['tag'], tag_1_cnt, tag_1);
            // 从所有标签集合中移除已被选择的标签，再随机选择标签凑齐5个（标签总数）
            let tag_set_rest = Array.from(difference(tag_set, new Set(tag_1)));
            current_tag_pool = shuffle(tag_1.concat(sample(tag_set_rest, tag_cnt - tag_1_cnt)));
            console.log('当前标签池', current_tag_pool);
            for (let i = 0; i < tag_cnt; i++) {
                document.getElementById(`div_tag_${i}`).innerHTML = current_tag_pool[i];
            }
        }

        function reset_overlay() {
            // 初始化代价抽取层
            flag_handle_cost_done = false;
            current_enabled_tag_indices.clear();
            current_disabled_tag_indices.clear();
            for (let i = 0; i < 9; i++) {
                document.getElementById(`div_tag_${i}`).classList.remove('div_tag_button_enabled');
                document.getElementById(`div_tag_${i}`).classList.remove('div_tag_button_enabled_useless');
                document.getElementById(`div_tag_${i}`).classList.remove('div_tag_button_disabled');
                document.getElementById(`div_tag_${i}`).classList.remove('div_tag_button_disabled_useless');
            }
            if (cost_mode == 0) {
                document.getElementById(`td_tag_comment`).innerHTML = '代价需求（最多3项）';
                document.getElementById(`div_tag_5`).style.display = "none";
                document.getElementById(`tr_tag_row_3`).style.display = "none";
            }
            if (cost_mode == 1) {
                document.getElementById(`td_tag_comment`).innerHTML = `禁用不想要的代价标签（最多5项）`;
                document.getElementById(`div_tag_5`).style.display = "";
                document.getElementById(`tr_tag_row_3`).style.display = "";
            }
            if (cost_mode == 2) {
                document.getElementById(`td_tag_comment`).innerHTML = `<span style="color:#00AAFF">选中想要的代价标签</span>（最多3项），<span style="color:#ebeb16">禁用不想要的代价标签</span>（最多5项）`;
                document.getElementById(`div_tag_5`).style.display = "";
                document.getElementById(`tr_tag_row_3`).style.display = "";
            }
            document.getElementById('td_cost_result').innerHTML = '这里显示抽出的代价';
            document.getElementById('div_cost_OK').innerHTML = '确认';
        }

        function draw_cost(cost_text) {
            document.getElementById(`td_cost_result`).innerHTML = cost_text;
        }

        function handle_wish(wish_index) {
            if (wish_index == -1) {
                handle_wish_options_toggle(true);
            }
            else {
                current_wish_index = wish_index;
                document.getElementById(`div_wish`).innerHTML = current_settings['wish'][wish_index];
                handle_wish_options_toggle();
            }
        }

        function handle_wish_options_toggle(is_on=false) {
            let now = new Date() * 1;
            if (now - last_toggle < 100) {
                return false;
            }
            if (is_on) {
                if (document.getElementById('div_wish_options').style.display == "none") {
                    document.getElementById('div_wish_options').style.display = "";
                }
                else {
                    document.getElementById('div_wish_options').style.display = "none";
                }
            }
            else {
                if (document.getElementById('div_wish_options')) {
                    document.getElementById('div_wish_options').style.display = "none";
                }
            }
            last_toggle = now;
        }

        function handle_md5() {
            current_settings_md5 = md5(JSON.stringify(current_settings));
            default_settings_md5 = md5(JSON.stringify(default_settings));
            document.getElementById('span_md5_0').innerHTML = current_settings_md5;
            document.getElementById('span_md5_1').innerHTML = current_settings_md5;
        }

        function handle_td_md5() {
            if (document.getElementById('td_md5').style.opacity == 0) {
                document.getElementById('td_md5').style.opacity = 1;
            }
            else {
                document.getElementById('td_md5').style.removeProperty('opacity');
            }
        }

        function handle_notice(code, message) {
            if (!code) {
                // 隐藏提示
                document.getElementById('tr_notice').style.display = 'none';
                // save_settings();
            }
            else if (code == 1 || code == 100) {
                // 设置更新
                set_settings_textarea();
                handle_md5();
                // save_settings();
                let notice_text = `设置已更新（${current_settings_md5.slice(0, 7)}）`;
                if (message) {
                    notice_text = `设置已更新（${current_settings_md5.slice(0, 7)} ${message}）`;
                }
                if (code == 1) {
                    // 初始化默认设置
                    notice_text = `已初始化默认设置（md5：${current_settings_md5}）`;
                }
                document.getElementById('td_notice').innerHTML = notice_text;
                document.getElementById('td_notice_button').innerHTML = `
                    <div class="div_notice_button" onclick="handle_button_settings();handle_notice();">查看</div>
                    <div class="div_notice_button" onclick="handle_notice();">好的</div>
                `;
                document.getElementById('tr_notice').style.display = '';
            }
            else if (code == 101) {
                // 使用新的默认设置
                save_backup_settings();
                set_default_settings();
                handle_notice(100);
            }
            else if (code == 102) {
                // 恢复以前的设置
                set_backup_settings();
                handle_notice(100);
            }
        }

        function get_update_message() {
            let xhr, repo_data, commit_data;
            xhr = new XMLHttpRequest();
            xhr.open('GET', 'https://api.github.com/repos/SonodaHanami/ganbouki/git/refs/heads/master', false);
            xhr.onreadystatechange = function() {
                if (xhr.readyState == 4 && xhr.status == 200 || xhr.status == 304) {
                    repo_data = JSON.parse(xhr.responseText);
                    console.log('load repo data');
                }
            };
            xhr.send(null);

            if (!repo_data) return false;
            xhr = new XMLHttpRequest();
            xhr.open('GET', repo_data['object']['url'], false);
            xhr.onreadystatechange = function() {
                if (xhr.readyState == 4 && xhr.status == 200 || xhr.status == 304) {
                    commit_data = JSON.parse(xhr.responseText);
                    update_message = commit_data['message'];
                    console.log('load commit data', commit_data['sha'].slice(0, 7), commit_data['message']);
                }
            };
            xhr.send(null);
        }

        function get_default_settings() {
            let xhr = new XMLHttpRequest();
            xhr.open('GET', 'beta.json', false);
            xhr.onreadystatechange = function() {
                // readyState == 4说明请求已完成
                if (xhr.readyState == 4 && xhr.status == 200 || xhr.status == 304) {
                    // 从服务器获得数据
                    default_settings = JSON.parse(xhr.responseText);
                    console.log('load default_settings', md5(JSON.stringify(default_settings)));
                }
            };
            xhr.send(null);
        }

        function set_backup_settings() {
            // 使用备份设置
            if (!window.localStorage) {
                console.error("浏览器不支持localStorage");
            }
            else {
                let storage = window.localStorage;
                let backup_settings = JSON.parse(storage['data_ganbouki_backup']);
                current_settings['wish'] = backup_settings['wish'];
                current_settings['cost'] = backup_settings['cost'];
                handle_md5();
            }
        }

        function set_default_settings() {
            // 使用默认设置
            current_settings['wish'] = default_settings['wish'];
            current_settings['cost'] = default_settings['cost'];
            handle_md5();
        }

        function set_settings_textarea() {
            document.getElementById('textarea_wish').value = current_settings['wish'].join('\n');
            document.getElementById('textarea_cost').value = current_settings['cost'].join('\n');
        }

        function load_settings() {
            get_default_settings();
            get_update_message();
            if (default_settings) {
                // 使用新的默认设置
                set_default_settings();
            }
            else {
                console.error("初始化设置失败，请刷新重试");
                document.getElementById('td_notice_2').innerHTML = "初始化设置失败，请刷新重试";
            }
        }

        function save_settings() {
            return false;
            if (!window.localStorage) {
                console.error("浏览器不支持localStorage");
            }
            else {
                console.log("save_settings()");
                let wish, cost, storage = window.localStorage;
                wish = document.getElementById('textarea_wish').value.split('\n');
                cost = document.getElementById('textarea_cost').value.split('\n');
                current_settings['wish'] = [];
                current_settings['cost'] = [];
                for (let i = 0; i < wish.length; i++) {
                    if (wish[i].trim().length > 0) {
                        current_settings['wish'].push(wish[i].trim());
                    }
                }
                for (let i = 0; i < cost.length; i++) {
                    if (cost[i].trim().length > 0) {
                        current_settings['cost'].push(cost[i].trim());
                    }
                }
                document.getElementById('textarea_wish').value = current_settings['wish'].join('\n');
                document.getElementById('textarea_cost').value = current_settings['cost'].join('\n');
                let data_to_save = {
                    'wish': current_settings['wish'],
                    'cost': current_settings['cost'],
                    'last_checked': last_checked,
                };
                storage['data_ganbouki'] = JSON.stringify(data_to_save);
                handle_md5();
                return true;
            }
        }

        function save_backup_settings() {
            if (!window.localStorage) {
                console.error("浏览器不支持localStorage");
            }
            else {
                console.log("save_backup_settings()");
                let wish, cost, storage = window.localStorage;
                storage['data_ganbouki_backup'] = JSON.stringify(current_settings);
            }
        }

        function handle_button_settings() {
            if (document.getElementById('table_settings').style.display == 'none') {
                document.getElementById('table_settings').style.display = '';
                document.getElementById('div_settings').innerHTML = "保存设置";
            }
            else {
                // if (save_settings()) {
                if (true) {
                    document.getElementById('tr_warning').style.display = 'none';
                    document.getElementById('table_settings').style.display = 'none';
                    document.getElementById('div_settings').innerHTML = '设置';
                    draw_row(false);
                };
            }
        }

        function handle_overlay() {
            if (document.getElementById('div_overlay_container').style.display == 'none') {
                document.getElementById('div_overlay_container').style.display = '';
                document.getElementById('div_cost_OK').onclick = handle_cost;
                if (flag_handle_cost_done) {
                    reset_cost_tag_pool();
                    reset_overlay();
                }
            }
            else {
                document.getElementById('div_overlay_container').style.display = 'none';
                document.getElementById('div_cost_OK').onclick = undefined;
            }
        }

        function handle_cost_paid(target) {
            console.log(target);
            if (document.getElementById(target).classList.contains('td_cost_not_paid')) {
                document.getElementById(target).classList.remove('td_cost_not_paid');
            }
            else {
                document.getElementById(target).classList.add('td_cost_not_paid');
            }
        }

        // 超集，set是否为subset的超集，即subset是否为set的子集
        function isSuperset(set, subset) {
            for (let elem of subset) {
                if (!set.has(elem)) {
                    return false;
                }
            }
            return true;
        }

        // 并集，合并去重
        function union(setA, setB) {
            let _union = new Set(setA);
            for (let elem of setB) {
                _union.add(elem);
            }
            return _union;
        }

        // 交集，同时属于A和B的元素的集合
        function intersection(setA, setB) {
            let _intersection = new Set();
            for (let elem of setB) {
                if (setA.has(elem)) {
                    _intersection.add(elem);
                }
            }
            return _intersection;
        }

        // 对称差集，不同时属于A或B的元素的集合
        function symmetricDifference(setA, setB) {
            let _difference = new Set(setA);
            for (let elem of setB) {
                if (_difference.has(elem)) {
                    _difference.delete(elem);
                } else {
                    _difference.add(elem);
                }
            }
            return _difference;
        }

        // 差集，属于A且不属于B的元素的集合
        function difference(setA, setB) {
            let _difference = new Set(setA);
            for (let elem of setB) {
                _difference.delete(elem);
            }
            return _difference;
        }

        // 从list中随机取出size个元素
        function sample(list, size) {
            if (size >= list.length) {
                return list;
            }
            let result = [];
            let indices = new Set();
            while (indices.size < size) {
                indices.add(Math.floor(Math.random() * list.length));
            }
            indices.forEach(index => {
                result.push(list[index]);
            });
            return result;
        }

        // 随机打乱数组
        function shuffle(array) {
            let currentIndex = array.length,  randomIndex;
            // While there remain elements to shuffle.
            while (currentIndex != 0) {
                // Pick a remaining element.
                randomIndex = Math.floor(Math.random() * currentIndex);
                currentIndex--;
                // And swap it with the current element.
                [array[currentIndex], array[randomIndex]] = [array[randomIndex], array[currentIndex]];
            }
            return array;
        }

        load_settings();
        draw_row();
        cost_mode = 2;
        reset_cost_tag_pool();
        reset_overlay();
        document.onclick = () => {
            handle_wish_options_toggle();
        }
        handle_td_md5();
    </script>
</body>
</html>